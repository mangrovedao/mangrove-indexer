// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

generator typegraphql {
  provider        = "typegraphql-prisma"
  simpleResolvers = true
}

// data model

// Very few chains, it should not be hard to query
model Chain {
  id   Int    @id
  name String

  transactions Transaction[]
  accounts     Account[]
  mangroves    Mangrove[]
  tokens       Token[]
}

//Many transactions, we have id has private key and it is there for indexed. Not sure if we need other fields indexed.

model Transaction {
  id          String   @id @db.VarChar(255)
  chainId     Int      @default(80001)
  txHash      String   @db.VarChar(80)
  from        String   @db.VarChar(80) // index?
  blockNumber Int
  blockHash   String   @db.VarChar(80)
  time        DateTime @db.Timestamp

  chain Chain @relation(fields: [chainId], references: [id])

  mangroveVersions      MangroveVersion[]
  takerApprovalVersions TakerApprovalVersion[]
  makerBalanceVersions  MakerBalanceVersion[]
  offerListingVersions  OfferListingVersion[]
  offerVersions         OfferVersion[]
  orders                Order[]
  MangroveOrderVersion  MangroveOrderVersion[]
  KandelVersion         KandelVersion[]
  KandelOfferIndex      KandelOfferIndex[]
  TokenBalanceVersion   TokenBalanceVersion[]
  KandelEvent           KandelEvent[]

  @@unique([chainId, txHash])
}

// probably have few tokens, so no extra index needed

model Token {
  id       String @id @db.VarChar(255)
  chainId  Int
  address  String @default("") @db.VarChar(80)
  symbol   String
  name     String
  decimals Int

  chain                      Chain               @relation(fields: [chainId], references: [id])
  offerListingsWhereInbound  OfferListing[]      @relation("OfferListingsByInboundToken")
  offerListingsWhereOutbound OfferListing[]      @relation("OfferListingsByOutboundToken")
  DepositWithdrawalStatus    TokenBalance[]
  kandelBase                 Kandel[]            @relation("base")
  kandelQuote                Kandel[]            @relation("quote")
  TokenBalanceEvent          TokenBalanceEvent[]

  @@unique([chainId, address])
}

// Few mangrove instances, no extra index needed

model Mangrove {
  id      String @id @db.VarChar(255)
  chainId Int    @default(-1)
  address String @default("") @db.VarChar(80)

  chain          Chain           @relation(fields: [chainId], references: [id])
  offerListings  OfferListing[]
  offers         Offer[]
  orders         Order[]
  makerBalances  MakerBalance[]
  takerApprovals TakerApproval[]

  currentVersionId String           @unique @db.VarChar(255)
  currentVersion   MangroveVersion? @relation("currentVersion", fields: [currentVersionId], references: [id])

  mangroveVersions MangroveVersion[] @relation("mangroveVersion")
  MangroveOrder    MangroveOrder[]
  Kandel           Kandel[]

  @@unique([chainId, address])
}

// Few mangrove instances, no extra index needed

model MangroveVersion {
  id         String   @id @db.VarChar(255)
  mangroveId String   @db.VarChar(255)
  txId       String?  @db.VarChar(255)
  governance String?
  monitor    String?
  vault      String?
  useOracle  Boolean?
  notify     Boolean?
  gasmax     Int?
  gasprice   Int?
  dead       Boolean?

  tx Transaction? @relation(fields: [txId], references: [id])

  versionNumber  Int
  prevVersionId  String?          @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    MangroveVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    MangroveVersion? @relation("prevVersion")
  currentVersion Mangrove?        @relation("currentVersion")
  mangrove       Mangrove?        @relation("mangroveVersion", fields: [mangroveId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  @@unique([mangroveId, versionNumber])
  @@index([txId])
}

// could potentially have many accounts, maybe extra indexes are needed.

model Account {
  id      String @id @db.VarChar(255)
  chainId Int    @default(80001)
  address String @db.VarChar(80) //index? 

  chain Chain @relation(fields: [chainId], references: [id])

  ownedTakerApprovals   TakerApproval[] @relation("OwnerApprovals")
  spenderTakerApprovals TakerApproval[] @relation("SpenderApprovals")
  offers                Offer[]
  orders                Order[]
  makerBalances         MakerBalance[]

  taker             MangroveOrder[]     @relation("taker")
  reserve           Kandel[]            @relation("reserveId")
  kandelOwner       KandelVersion[]     @relation("admin")
  TokenBalance      TokenBalance[]      @relation("reserve")
  TokenBalanceEvent TokenBalanceEvent[]
  kandel            Kandel?             @relation("strat")
  mangroveOrder     MangroveOrder[]     @relation("mangroveOrder")

  @@unique([chainId, address])
}

// could potentially have many approvals, extra indexes might be needed.

model TakerApproval {
  id             String @id @db.VarChar(255)
  mangroveId     String @db.VarChar(255)
  offerListingId String @db.VarChar(255)
  ownerId        String @db.VarChar(255) // index?
  spenderId      String @db.VarChar(255) // index?

  mangrove     Mangrove     @relation(fields: [mangroveId], references: [id])
  offerListing OfferListing @relation(fields: [offerListingId], references: [id])
  owner        Account      @relation("OwnerApprovals", fields: [ownerId], references: [id])
  spender      Account      @relation("SpenderApprovals", fields: [spenderId], references: [id])

  currentVersionId String                @unique @db.VarChar(255)
  currentVersion   TakerApprovalVersion? @relation("currentVersion", fields: [currentVersionId], references: [id])

  takerApprovalVersions TakerApprovalVersion[] @relation("takerApprovalVersion")

  @@unique([mangroveId, offerListingId, ownerId, spenderId])
  @@index([offerListingId])
  @@index([ownerId])
  @@index([spenderId])
}

// could potentially have many approvals, extra indexes might be needed.

model TakerApprovalVersion {
  id              String  @id @db.VarChar(255)
  takerApprovalId String  @db.VarChar(255) // index?
  txId            String  @db.VarChar(255) // index?
  parentOrderId   String? @db.VarChar(255)
  value           String  @db.VarChar(80)

  tx          Transaction @relation(fields: [txId], references: [id])
  parentOrder Order?      @relation(fields: [parentOrderId], references: [id])

  versionNumber  Int
  prevVersionId  String?               @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    TakerApprovalVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    TakerApprovalVersion? @relation("prevVersion")
  currentVersion TakerApproval?        @relation("currentVersion")
  takerApproval  TakerApproval         @relation("takerApprovalVersion", fields: [takerApprovalId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  @@unique([takerApprovalId, versionNumber])
  @@index([txId])
  @@index([parentOrderId])
}

// could potentially have many makers, but extra indexes probably not needed

model MakerBalance {
  id         String @id @db.VarChar(255)
  mangroveId String @db.VarChar(100)
  makerId    String @db.VarChar(255)

  mangrove Mangrove @relation(fields: [mangroveId], references: [id])
  maker    Account  @relation(fields: [makerId], references: [id])

  currentVersionId String               @unique @db.VarChar(255)
  currentVersion   MakerBalanceVersion? @relation("currentVersion", fields: [currentVersionId], references: [id])

  makerBalanceVersions MakerBalanceVersion[] @relation("makerBalanceVersion")

  @@unique([mangroveId, makerId])
  @@index([makerId])
}

// Many makers with many versions, could need extra indexes.

model MakerBalanceVersion {
  id             String @id @db.VarChar(255)
  makerBalanceId String @db.VarChar(255) // index?
  txId           String @db.VarChar(255) // index?
  balance        String @db.VarChar(80)

  tx Transaction @relation(fields: [txId], references: [id])

  versionNumber  Int
  prevVersionId  String?              @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    MakerBalanceVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    MakerBalanceVersion? @relation("prevVersion")
  currentVersion MakerBalance?        @relation("currentVersion")
  makerBalance   MakerBalance         @relation("makerBalanceVersion", fields: [makerBalanceId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  @@unique([makerBalanceId, versionNumber])
  @@index([txId])
}

// probably very few offerlists, no extra indexes needed
/// The name should be "OfferList" but Prisma will generate wrong queries if the name ends with "List"
model OfferListing {
  id              String @id @db.VarChar(255)
  mangroveId      String @db.VarChar(255)
  inboundTokenId  String @db.VarChar(255)
  outboundTokenId String @db.VarChar(255)

  mangrove       Mangrove        @relation(fields: [mangroveId], references: [id])
  inboundToken   Token           @relation(name: "OfferListingsByInboundToken", fields: [inboundTokenId], references: [id])
  outboundToken  Token           @relation(name: "OfferListingsByOutboundToken", fields: [outboundTokenId], references: [id])
  offers         Offer[]
  takerApprovals TakerApproval[]
  orders         Order[]

  MangroveOrder        MangroveOrder[]
  currentVersionId     String                @unique @db.VarChar(255)
  currentVersion       OfferListingVersion?  @relation("currentVersion", fields: [currentVersionId], references: [id])
  offerListingVersions OfferListingVersion[] @relation("offerListingVersion")
  MangroveOrderFill    MangroveOrderFill[]

  @@unique([mangroveId, inboundTokenId, outboundTokenId])
  @@index([inboundTokenId])
  @@index([outboundTokenId])
}

// few offerlist, will have some versions, but not enough for it to need extra indexes

model OfferListingVersion {
  id             String   @id @db.VarChar(255)
  offerListingId String   @db.VarChar(255)
  txId           String   @db.VarChar(255)
  active         Boolean?
  fee            String?  @db.VarChar(80)
  gasbase        Int?
  density        String?  @db.VarChar(80)

  tx Transaction @relation(fields: [txId], references: [id])

  versionNumber  Int
  prevVersionId  String?              @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    OfferListingVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    OfferListingVersion? @relation("prevVersion")
  currentVersion OfferListing?        @relation("currentVersion")
  offerListing   OfferListing         @relation("offerListingVersion", fields: [offerListingId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  @@unique([offerListingId, versionNumber])
  @@index([txId])
}

// Could potentially have many offers, maybe extra indexes are needed.

model Offer {
  id             String @id @db.VarChar(255)
  mangroveId     String @db.VarChar(255)
  offerListingId String @db.VarChar(255)
  makerId        String @db.VarChar(255) // index?
  offerNumber    Int

  // Instead, we create new versions or mark the offer as deleted, which makes undo easy.

  mangrove      Mangrove        @relation(fields: [mangroveId], references: [id])
  MangroveOrder MangroveOrder[]
  offerListing  OfferListing    @relation(fields: [offerListingId], references: [id])
  maker         Account         @relation(fields: [makerId], references: [id])

  currentVersionId   String              @unique @db.VarChar(255)
  currentVersion     OfferVersion?       @relation("currentVersion", fields: [currentVersionId], references: [id])
  offerVersions      OfferVersion[]      @relation("offerVersion")
  kandelOfferIndexes KandelOfferIndex?   @relation("offerIndex")
  KandelOfferUpdate  KandelOfferUpdate[]

  @@unique([mangroveId, offerListingId, offerNumber])
  @@index([offerListingId])
  @@index([makerId])
}

// Many offers, each having many version, we probably need indexes here.

model OfferVersion {
  id                    String  @id @db.VarChar(255)
  offerId               String  @db.VarChar(255) // index?
  txId                  String  @db.VarChar(255)
  parentOrderId         String? @db.VarChar(255) // index?
  prevOfferId           String? @db.VarChar(255) // what is this?
  deleted               Boolean @default(false) // The offer has been deleted
  wants                 String  @db.VarChar(80)
  wantsNumber           Float
  gives                 String  @db.VarChar(80)
  givesNumber           Float
  takerPaysPrice        Float?
  makerPaysPrice        Float?
  gasprice              Int
  gasreq                Int
  live                  Boolean
  deprovisioned         Boolean
  kandelPopulateEventId String? @db.VarChar(255)
  kandelRetractEventId  String?

  tx          Transaction @relation(fields: [txId], references: [id])
  parentOrder Order?      @relation(fields: [parentOrderId], references: [id])

  versionNumber  Int
  prevVersionId  String?       @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    OfferVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    OfferVersion? @relation("prevVersion")
  currentVersion Offer?        @relation("currentVersion")
  offer          Offer         @relation("offerVersion", fields: [offerId], references: [id], onDelete: Restrict, onUpdate: Restrict) // This points to the older version that this version replaces, if any
  TakenOffer     TakenOffer[]

  @@index([txId])
  @@index([offerId])
  @@index([parentOrderId])
  @@index([kandelPopulateEventId])
  @@index([kandelRetractEventId])
}

// could have many orders. probably needs extra indexes.

model Order {
  id              String  @id @db.VarChar(255)
  txId            String  @db.VarChar(255) // index?
  parentOrderId   String? @db.VarChar(255)
  mangroveId      String  @db.VarChar(255)
  offerListingId  String  @db.VarChar(255) // maybe index?
  takerId         String  @db.VarChar(255) // index?
  proximaId       String  @db.VarChar(255)
  // takerWants       String
  // takerWantsNumber Float
  // takerGives       String
  // takerGivesNumber Float
  takerGot        String
  takerGotNumber  Float
  takerGave       String
  takerGaveNumber Float
  takerPaidPrice  Float?
  makerPaidPrice  Float?
  totalFee        String
  totalFeeNumber  Float
  bounty          String
  bountyNumber    Float

  tx          Transaction @relation(fields: [txId], references: [id])
  parentOrder Order?      @relation("ParentOrders", fields: [parentOrderId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  takenOffers                TakenOffer[]
  mangrove                   Mangrove               @relation(fields: [mangroveId], references: [id])
  offerListing               OfferListing           @relation(fields: [offerListingId], references: [id])
  taker                      Account                @relation(fields: [takerId], references: [id])
  childOrders                Order[]                @relation("ParentOrders")
  childTakerApprovalVersions TakerApprovalVersion[]
  childOfferVersions         OfferVersion[]
  MangroveOrder              MangroveOrder[]

  @@index([txId])
  @@index([parentOrderId])
  @@index([mangroveId])
  @@index([offerListingId])
  @@index([takerId])
}

// With many offers and offer versions, we could have many takenOffers, this probably needs indexes
// Why no reference to the actuall offer( and its version), that was taken?

model TakenOffer {
  id              String  @id @db.VarChar(255)
  orderId         String  @db.VarChar(255) // index?
  offerVersionId  String  @db.VarChar(255)
  takerGot        String
  takerGotNumber  Float
  takerGave       String
  takerGaveNumber Float
  takerPaidPrice  Float?
  makerPaidPrice  Float?
  posthookFailed  Boolean
  posthookData    String?
  failReason      String?

  order             Order               @relation(fields: [orderId], references: [id], onDelete: Cascade)
  offerVersion      OfferVersion        @relation(fields: [offerVersionId], references: [id], onDelete: Cascade)
  TokenBalanceEvent TokenBalanceEvent[]

  @@unique([orderId, offerVersionId])
  @@index([offerVersionId])
}

// strats

// potentially many, maybe add index
// Should we not be able to find what orders were created? and what offers were taken?
// We are only able to get the restingOrder.
// - Is this doable by looking up the txId? and finding the orders and offers that way?
//  - - If so, then maybe we need indexes on txId for other tables.

// Clean up and ref orderId

// This should be MangroveOrder and MangroveOrderVersion, with all the parameteres for MangroveOrder

model MangroveOrder {
  id String @id @db.VarChar(255)

  mangroveId       String  @db.VarChar(255)
  stratId          String  @db.VarChar(255)
  offerListingId   String  @db.VarChar(255)
  takerId          String  @db.VarChar(255)
  proximaId        String  @db.VarChar(255)
  orderId          String  @db.VarChar(255)
  restingOrderId   String? @db.VarChar(255) // maybe index?
  restingOrder     Boolean
  fillOrKill       Boolean
  fillWants        Boolean
  takerWants       String
  takerWantsNumber Float
  takerGives       String
  takerGivesNumber Float
  bounty           String
  bountyNumber     Float
  totalFee         String
  totalFeeNumber   Float

  currentVersionId String                @unique @db.VarChar(255)
  currentVersion   MangroveOrderVersion? @relation("currentVersion", fields: [currentVersionId], references: [id])

  mangrove             Mangrove               @relation(fields: [mangroveId], references: [id])
  strat                Account                @relation("mangroveOrder", fields: [stratId], references: [id])
  offerListing         OfferListing           @relation(fields: [offerListingId], references: [id])
  taker                Account                @relation("taker", fields: [takerId], references: [id])
  order                Order                  @relation(fields: [orderId], references: [id])
  offer                Offer?                 @relation(fields: [restingOrderId], references: [id])
  MangroveOrderVersion MangroveOrderVersion[] @relation("mangroveOrderVersion")

  @@unique([mangroveId, orderId])
  @@index([stratId])
  @@index([offerListingId])
  @@index([takerId])
  @@index([orderId])
  @@index([restingOrderId])
}

model MangroveOrderVersion {
  id              String   @id @db.VarChar(255)
  txId            String   @db.VarChar(255)
  mangroveOrderId String   @db.VarChar(255)
  filled          Boolean
  cancelled       Boolean  @default(false)
  failed          Boolean
  failedReason    String?
  takerGot        String
  takerGotNumber  Float
  takerGave       String
  takerGaveNumber Float
  price           Float
  // penalty         String // TODO: Add when available
  // penaltyNumber   Float
  expiryDate      DateTime @db.Timestamp

  tx Transaction @relation(fields: [txId], references: [id])

  versionNumber  Int
  prevVersionId  String?               @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    MangroveOrderVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    MangroveOrderVersion? @relation("prevVersion")
  currentVersion MangroveOrder?        @relation("currentVersion")
  mangroveOrder  MangroveOrder         @relation("mangroveOrderVersion", fields: [mangroveOrderId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  @@unique([mangroveOrderId, versionNumber])
  @@index([txId])
}

model TokenBalance {
  id        String @id @db.VarChar(255)
  accountId String @map("reserveId") @db.VarChar(255)
  tokenId   String @db.VarChar(255)

  currentVersionId String                @unique @db.VarChar(255)
  currentVersion   TokenBalanceVersion?  @relation("currentVersion", fields: [currentVersionId], references: [id])
  token            Token                 @relation(fields: [tokenId], references: [id])
  reserve          Account               @relation("reserve", fields: [accountId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  allBalances      TokenBalanceVersion[] @relation("tokenBalance")

  @@unique([accountId, tokenId])
  @@index([tokenId])
}

model TokenBalanceEvent {
  id                    String  @id @default(uuid())
  accountId             String  @map("reserveId") @db.VarChar(255)
  tokenId               String  @db.VarChar(255)
  tokenBalanceVersionId String  @unique @db.VarChar(255)
  takenOfferId          String? @db.VarChar(255)

  tokenBalanceVersion TokenBalanceVersion @relation(fields: [tokenBalanceVersionId], references: [id], onDelete: Cascade)
  token               Token               @relation(fields: [tokenId], references: [id])

  reserve                     Account                      @relation(fields: [accountId], references: [id])
  TokenBalanceDepositEvent    TokenBalanceDepositEvent?
  TokenBalanceWithdrawalEvent TokenBalanceWithdrawalEvent?
  takenOffer                  TakenOffer?                  @relation(fields: [takenOfferId], references: [id], onDelete: Cascade)

  @@index([tokenId])
  @@index([accountId])
  @@index([takenOfferId])
}

model TokenBalanceDepositEvent {
  id                  String            @id @default(uuid())
  tokenBalanceEventId String            @unique @db.VarChar(255)
  tokenBalanceEvent   TokenBalanceEvent @relation(fields: [tokenBalanceEventId], references: [id], onDelete: Cascade)
  source              String
  value               String
  kandel              Kandel?           @relation("depositEvent", fields: [source], references: [id])

  @@index([source])
}

model TokenBalanceWithdrawalEvent {
  id                  String            @id @default(uuid())
  tokenBalanceEventId String            @unique @db.VarChar(255)
  tokenBalanceEvent   TokenBalanceEvent @relation(fields: [tokenBalanceEventId], references: [id], onDelete: Cascade)
  source              String
  value               String
  kandel              Kandel?           @relation("withdrawalEvent", fields: [source], references: [id])

  @@index([source])
}

model TokenBalanceVersion {
  id             String @id @db.VarChar(255)
  txId           String @db.VarChar(255)
  tokenBalanceId String @db.VarChar(255)
  deposit        String
  withdrawal     String
  send           String
  received       String
  balance        String

  tx           Transaction  @relation(fields: [txId], references: [id])
  tokenBalance TokenBalance @relation("tokenBalance", fields: [tokenBalanceId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  versionNumber                    Int
  prevVersionId                    String?              @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion                      TokenBalanceVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion                      TokenBalanceVersion? @relation("prevVersion")
  currentVersion                   TokenBalance?        @relation("currentVersion")
  TokenBalanceEvent                TokenBalanceEvent?
  populateBaseTokenBalanceVersion  KandelPopulateEvent? @relation("populateBaseTokenBalanceVersion")
  populateQuoteTokenBalanceVersion KandelPopulateEvent? @relation("populateQuoteTokenBalanceVersion")
  retractBaseTokenBalanceVersion   KandelRetractEvent?  @relation("retractBaseTokenBalanceVersion")
  retractQuoteTokenBalanceVersion  KandelRetractEvent?  @relation("retractQuoteTokenBalanceVersion")

  @@unique([tokenBalanceId, versionNumber])
  @@index([txId])
}

model Kandel {
  id         String @id @unique @db.VarChar(255)
  mangroveId String @db.VarChar(255)
  baseId     String @db.VarChar(255)
  quoteId    String @db.VarChar(255)
  reserveId  String @db.VarChar(255)
  type       String

  currentVersionId            String                        @unique @db.VarChar(255)
  currentVersion              KandelVersion?                @relation("currentVersion", fields: [currentVersionId], references: [id])
  baseToken                   Token                         @relation("base", fields: [baseId], references: [id])
  quoteToken                  Token                         @relation("quote", fields: [quoteId], references: [id])
  mangrove                    Mangrove                      @relation(fields: [mangroveId], references: [id])
  strat                       Account                       @relation("strat", fields: [id], references: [id])
  reserve                     Account                       @relation("reserveId", fields: [reserveId], references: [id])
  kandelVersions              KandelVersion[]               @relation("kandelVersion")
  kandelOfferIndexes          KandelOfferIndex[]            @relation("offerIndex")
  KandelEvent                 KandelEvent[]
  TokenBalanceDepositEvent    TokenBalanceDepositEvent[]    @relation("depositEvent")
  TokenBalanceWithdrawalEvent TokenBalanceWithdrawalEvent[] @relation("withdrawalEvent")

  @@index([baseId])
  @@index([quoteId])
  @@index([mangroveId])
  @@index([reserveId])
}

model KandelOfferIndex {
  offerId  String @unique @db.VarChar(255)
  kandelId String @db.VarChar(255)
  txId     String @db.VarChar(255)
  index    Int
  ba       String

  offer  Offer       @relation("offerIndex", fields: [offerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  kandel Kandel      @relation("offerIndex", fields: [kandelId], references: [id])
  tx     Transaction @relation(fields: [txId], references: [id])

  @@id([offerId, kandelId, ba])
  @@index([kandelId])
  @@index([txId])
}

model KandelEvent {
  id              String  @id @default(uuid())
  txId            String  @db.VarChar(255)
  kandelVersionId String? @unique @db.VarChar(255)
  kandelId        String  @db.VarChar(255)

  transaction                Transaction                 @relation(fields: [txId], references: [id])
  kandel                     Kandel                      @relation(fields: [kandelId], references: [id])
  KandelVersion              KandelVersion?              @relation("kandelVersion", fields: [kandelVersionId], references: [id], onDelete: Cascade)
  compoundRateEvent          KandelCompoundRateEvent?
  gasPriceEvent              KandelGasPriceEvent?
  KandelGasReqEvent          KandelGasReqEvent?
  KandelGeometricParamsEvent KandelGeometricParamsEvent?
  KandelLengthEvent          KandelLengthEvent?
  KandelAdminEvent           KandelAdminEvent?
  KandelRouterEvent          KandelRouterEvent?
  KandelPopulateEvent        KandelPopulateEvent?
  NewKandelEvent             NewKandelEvent?
  KandelRetractEvent         KandelRetractEvent?

  @@index([kandelId])
  @@index([txId])
}

model KandelCompoundRateEvent {
  id                String      @id @default(uuid())
  eventId           String      @unique @db.VarChar(255)
  compoundRateBase  Float
  compoundRateQuote Float
  event             KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelGasPriceEvent {
  id       String      @id @default(uuid())
  eventId  String      @unique @db.VarChar(255)
  gasPrice String
  event    KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelGasReqEvent {
  id      String      @id @default(uuid())
  eventId String      @unique @db.VarChar(255)
  gasReq  String
  event   KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelGeometricParamsEvent {
  id      String      @id @default(uuid())
  eventId String      @unique @db.VarChar(255)
  ratio   Float
  spread  Float
  event   KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelLengthEvent {
  id      String      @id @default(uuid())
  eventId String      @unique @db.VarChar(255)
  length  Int
  event   KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelAdminEvent {
  id      String      @id @default(uuid())
  eventId String      @unique @db.VarChar(255)
  admin   String
  event   KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelRouterEvent {
  id      String      @id @default(uuid())
  eventId String      @unique @db.VarChar(255)
  router  String
  event   KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model NewKandelEvent {
  id      String      @id @default(uuid())
  eventId String      @unique @db.VarChar(255)
  event   KandelEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model KandelPopulateEvent {
  id                         String  @id @default(uuid())
  eventId                    String  @unique @db.VarChar(255)
  baseTokenBalanceVersionId  String? @unique @db.VarChar(255)
  quoteTokenBalanceVersionId String? @unique @db.VarChar(255)

  event                    KandelEvent          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  baseTokenBalanceVersion  TokenBalanceVersion? @relation("populateBaseTokenBalanceVersion", fields: [baseTokenBalanceVersionId], references: [id])
  quoteTokenBalanceVersion TokenBalanceVersion? @relation("populateQuoteTokenBalanceVersion", fields: [quoteTokenBalanceVersionId], references: [id])
  KandelOfferUpdate        KandelOfferUpdate[]  @relation("kandelOfferUpdatePopulate")
}

model KandelOfferUpdate {
  eventId String @db.VarChar(255)
  offerId String @db.VarChar(255)

  gives String

  offer         Offer                @relation(fields: [offerId], references: [id])
  populateEvent KandelPopulateEvent? @relation("kandelOfferUpdatePopulate", references: [id], fields: [eventId], map: "populateEvent", onDelete: Cascade)
  retractEvent  KandelRetractEvent?  @relation("kandelOfferUpdateRetract", references: [id], fields: [eventId], map: "retractEvent", onDelete: Cascade)

  @@id([eventId, offerId])
  @@index([eventId])
  @@index([offerId])
}

model KandelRetractEvent {
  id                         String              @id @default(uuid())
  eventId                    String              @unique @db.VarChar(255)
  baseTokenBalanceVersionId  String?             @unique @db.VarChar(255)
  quoteTokenBalanceVersionId String?             @unique @db.VarChar(255)
  event                      KandelEvent         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  KandelOfferUpdate          KandelOfferUpdate[] @relation("kandelOfferUpdateRetract")

  baseTokenBalanceVersion  TokenBalanceVersion? @relation("retractBaseTokenBalanceVersion", fields: [baseTokenBalanceVersionId], references: [id])
  quoteTokenBalanceVersion TokenBalanceVersion? @relation("retractQuoteTokenBalanceVersion", fields: [quoteTokenBalanceVersionId], references: [id])
}

model KandelVersion {
  id              String @id @db.VarChar(255)
  kandelId        String @db.VarChar(255)
  txId            String @db.VarChar(255)
  congigurationId String @db.VarChar(255)
  adminId         String @db.VarChar(255)

  routerAddress String @db.VarChar(255)

  tx            Transaction         @relation(fields: [txId], references: [id])
  configuration KandelConfiguration @relation(fields: [congigurationId], references: [id])
  admin         Account             @relation("admin", fields: [adminId], references: [id])
  event         KandelEvent?        @relation("kandelVersion")

  versionNumber  Int
  prevVersionId  String?        @unique @db.VarChar(255) // This points to the older version that this version replaces, if any
  prevVersion    KandelVersion? @relation("prevVersion", fields: [prevVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  nextVersion    KandelVersion? @relation("prevVersion")
  currentVersion Kandel?        @relation("currentVersion")
  kandel         Kandel         @relation("kandelVersion", fields: [kandelId], references: [id], onDelete: Restrict, onUpdate: Restrict)

  @@unique([kandelId, versionNumber])
  @@index([txId])
  @@index([congigurationId])
  @@index([adminId])
}

model KandelConfiguration {
  id                String          @id @default(uuid())
  compoundRateBase  Float // Are these big numbers?
  compoundRateQuote Float // Are these big numbers?
  gasPrice          String
  gasReq            String
  spread            Float
  ratio             Float
  length            Int
  KandelVersion     KandelVersion[]
}

// store consumed streams offsets
model Streams {
  id     String @id @db.VarChar(255)
  offset String @db.VarChar(255)
}

view MangroveOrderFill {
  mangroveId      String
  takerId         String
  offerListingId  String
  mangroveOrderId String?
  fillsId         String // Either a TakenOfferId or OrderId
  type            String
  totalFee        Float
  amount          Float
  price           Float?
  txHash          String
  time            DateTime @db.Timestamp

  offerListing OfferListing @relation(fields: [offerListingId], references: [id])

  @@unique([type, fillsId])
  @@index([takerId])
  @@index([mangroveId])
  @@index([offerListingId])
}
